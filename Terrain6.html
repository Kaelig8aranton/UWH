<!-- 
Ce terrain interactif a été codé par Kaëlig BARANTON, initialement pour le hockey subaquatique.
Vous êtes libre de l’utiliser et de le modifier comme bon vous semble. N’hésitez pas à me faire part de vos améliorations ou de vos bonnes idées.
Vous pouvez aussi proposer vos modifications à cette adresse :
https://github.com/Kaelig8aranton/UWH/blob/main/Terrain6.html
Vous pouvez me contacter à l’adresse suivante : mantereligieuse01@gmail.com

This interactive field was coded by Kaëlig BARANTON, originally for underwater hockey.
You are free to use and modify it as you wish — feel free to share your improvements or ideas with me.
You can also suggest changes here:
https://github.com/Kaelig8aranton/UWH/blob/main/Terrain6.html
You can contact me at the following address: mantereligieuse01@gmail.com

Este terreno interactivo fue programado por Kaëlig BARANTON, originalmente para el hockey subacuático.
Eres libre de usarlo y modificarlo como quieras. No dudes en compartirme tus mejoras o buenas ideas.
También puedes proponer tus modificaciones en esta dirección:
https://github.com/Kaelig8aranton/UWH/blob/main/Terrain6.html
Puedes contactarme en la siguiente dirección: mantereligieuse01@gmail.com
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Hockey Court Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #000000;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            width: 100%;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .court-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
            overflow: hidden;
        }

        #courtCanvas {
            border: 1px solid #000000;
            background-color: rgb(255, 255, 255);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            max-height: 100%;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }

        .control-btn {
            padding: 12px 16px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .control-btn:hover, .control-btn:active {
            background-color: #356ac3;
        }

        .player-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .player-btn {
            padding: 10px 14px;
            background-color: #e0e0e0;
            border: 1px solid #ccc;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            min-width: 44px;
            text-align: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .player-btn:hover, .player-btn:active {
            background-color: #d0d0d0;
        }

        .player-btn.selected {
            background-color: #4285f4;
            color: white;
        }

        .instructions {
            margin-top: 5px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="court-container">
            <canvas id="courtCanvas"></canvas>
        </div>
        <div class="controls">
            <div class="control-buttons">
                <button id="toggle-formation" class="control-btn">Switch to 3-3</button>
            </div>
            <div class="player-buttons">
                <div id="buttons-231">
                    <button class="player-btn" data-player="FL">FL</button>
                    <button class="player-btn" data-player="FR">FR</button>
                    <button class="player-btn" data-player="WL">WL</button>
                    <button class="player-btn" data-player="C">C</button>
                    <button class="player-btn" data-player="WR">WR</button>
                    <button class="player-btn" data-player="FB">FB</button>
                </div>
                <div id="buttons-33" style="display: none;">
                    <button class="player-btn" data-player="AG">AG</button>
                    <button class="player-btn" data-player="AVC">AVC</button>
                    <button class="player-btn" data-player="AD">AD</button>
                    <button class="player-btn" data-player="PG">PG</button>
                    <button class="player-btn" data-player="AR">AR</button>
                    <button class="player-btn" data-player="PD">PD</button>
                </div>
            </div>
            <div class="instructions">
                <p>Click and drag to move puck • Click on player to select them</p>
            </div>
        </div>
    </div>
    <script>
        // Hockey Court Visualization - JavaScript translation of Python code

        // Court dimensions and settings
        const courtWidth = 15;
        const courtLength = 25;
        let scaleFactor = 20; // Default scale factor, will be updated on resize

        // Player constants
        const distBetweenForward = 0.8;
        const distBetweenMid = 1.3;
        const distFBPuck = 2;
        const distanceAvantPuck = -0.4;
        const distanceMilieuPuck = 1;
        const distEntreLigne = 1.5;

        // Initialize canvas and context
        const canvas = document.getElementById('courtCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to maintain aspect ratio and fit screen
        function resizeCanvas() {
            const container = document.querySelector('.court-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Calculate the available space
            const maxWidth = containerWidth - 20; // 10px padding on each side
            const maxHeight = containerHeight - 20; // 10px padding on each side
            
            // Full field view: aspect ratio is 15/25
            const aspectRatio = courtWidth / courtLength;
            
            let canvasWidth, canvasHeight;
            if (maxWidth / aspectRatio <= maxHeight) {
                // Width constrained
                canvasWidth = maxWidth;
                canvasHeight = maxWidth / aspectRatio;
            } else {
                // Height constrained
                canvasHeight = maxHeight;
                canvasWidth = maxHeight * aspectRatio;
            }
            
            // Set canvas dimensions
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // Calculate scale factor based on canvas size
            scaleFactor = canvasWidth / courtWidth;
            
            // Redraw everything
            drawCourt();
            drawPlayers();
        }

        // Calculate pixel positions from court coordinates
        function courtToPixelX(x) {
            return x * scaleFactor;
        }

        function courtToPixelY(y) {
            return canvas.height - y * scaleFactor; // Invert Y because canvas Y increases downward
        }

        // Initialize player positions and variables
        let currentFormation = '33'; // Default formation
        let selectedPlayer = null;
        let puckX = courtWidth / 2;
        let puckY = courtLength / 2;
        let isDragging = false;
        let startDragX, startDragY;
        let startPuckX, startPuckY;
        let animationActive = true; // Flag to indicate when animation is running

        // Initialize player positions for both formations
        let points231 = {
            'FL': [courtWidth/2-1, courtLength/4],
            'FR': [courtWidth/2+1, courtLength/4],
            'WL': [courtWidth/2-2, courtLength/2],
            'C': [courtWidth/2, courtLength/2],
            'WR': [courtWidth/2+2, courtLength/2],
            'FB': [courtWidth/2, 3*courtLength/4]
        };

        let points33 = {
            'AG': [courtWidth/2-2, courtLength/4], 
            'AD': [courtWidth/2+2, courtLength/4],
            'AVC': [courtWidth/2, courtLength/4],
            'AR': [courtWidth/2, courtLength/2],
            'PD': [courtWidth/2+2, 3*courtLength/4],
            'PG': [courtWidth/2-2, 3*courtLength/4]
        };

        // Helper function for rotation calculations for 231 formation
        function calcRot231(paletX) {
            const angle = (paletX / courtWidth) * Math.PI;
            return distBetweenForward * Math.cos(angle);
        }

        // Helper function for rotation calculations for 33 formation
        function calcRot33(paletX) {
            const angle = (paletX / courtWidth) * Math.PI;
            return distBetweenForward * Math.cos(angle);
        }

        // Position update functions for 231 formation
        function updateFL(paletX, paletY, paletLabel) {
            if (paletLabel === 'FL') {
                points231.FL = [paletX, paletY - 0.2];
            } else if (paletLabel === 'FR') {
                points231.FL = [paletX - distBetweenForward, paletY - 0.2];
            } else if (paletLabel === 'WL') {
                points231.FL = [paletX, paletY + 1];
            } else if (paletLabel === 'WR') {
                points231.FL = [paletX - distBetweenForward, paletY + 1];
            } else if (paletLabel === 'C') {
                points231.FL = [paletX - distBetweenForward, paletY + 1];
            } else if (paletLabel === 'FB') {
                points231.FL = [paletX - distBetweenForward, paletY + 2];
            } else {
                points231.FL = [paletX - distBetweenForward, paletY - distanceAvantPuck];
            }
        }

        function updateFR(paletX, paletY, paletLabel) {
            if (paletLabel === 'FR') {
                points231.FR = [paletX, paletY - 0.2];
            } else if (paletLabel === 'FL') {
                points231.FR = [paletX + distBetweenForward, paletY - 0.2];
            } else if (paletLabel === 'WL') {
                points231.FR = [paletX + distBetweenForward, paletY + 1];
            } else if (paletLabel === 'WR') {
                points231.FR = [paletX, paletY + 1];
            } else if (paletLabel === 'C') {
                points231.FR = [paletX + distBetweenForward, paletY + 1];
            } else if (paletLabel === 'FB') {
                points231.FR = [paletX + distBetweenForward, paletY + 2];
            } else {
                points231.FR = [paletX + distBetweenForward, paletY - distanceAvantPuck];
            }
        }

        function updateWL(paletX, paletY, paletLabel) {
            let rot = calcRot231(paletX);
            if (rot < -0.4) rot = -0.4;
            
            if (paletLabel === 'WL') {
                points231.WL = [paletX, paletY - 0.2];
            } else if (paletLabel === 'FL') {
                points231.WL = [paletX - distBetweenMid/2, paletY - 0.2 - 1 + rot];
            } else if (paletLabel === 'FR') {
                const [xC, yC] = points231.C;
                points231.WL = [xC - distBetweenMid, paletY - 1 + rot];
            } else if (paletLabel === 'WR') {
                const [xWR, yWR] = points231.WR;
                points231.WL = [paletX - 2*distBetweenMid, yWR + 2*rot];
            } else if (paletLabel === 'C') {
                const [xC, yC] = points231.C;
                points231.WL = [paletX - distBetweenMid, yC + rot];
            } else if (paletLabel === 'FB') {
                points231.WL = [paletX - distBetweenMid, paletY];
            } else {
                points231.WL = [paletX - distBetweenMid, paletY - distanceMilieuPuck + rot - 0.2];
            }
            
            if (points231.WL[0] > courtWidth - 2*distBetweenMid) {
                points231.WL[0] = courtWidth - 2*distBetweenMid;
            }
        }

        function updateC(paletX, paletY, paletLabel) {
            const rot = calcRot231(paletX);
            
            if (paletLabel === 'C') {
                points231.C = [paletX, paletY - 0.2];
            } else if (paletLabel === 'FL') {
                points231.C = [paletX + distBetweenForward/2, paletY - 0.2 - 1];
            } else if (paletLabel === 'FR') {
                points231.C = [paletX - distBetweenForward/2, paletY - 0.2 - 1];
            } else if (paletLabel === 'WR') {
                const [xWR, yWR] = points231.WR;
                points231.C = [paletX - distBetweenMid, yWR + rot/2];
            } else if (paletLabel === 'WL') {
                const [xWL, yWL] = points231.WL;
                points231.C = [paletX + distBetweenMid, yWL - rot/2];
            } else if (paletLabel === 'FB') {
                points231.C = [paletX, paletY - 1];
            } else {
                points231.C = [paletX, paletY - distanceMilieuPuck];
            }
            
            if (points231.C[0] < distBetweenMid) {
                points231.C[0] = distBetweenMid;
            } else if (points231.C[0] > courtWidth - distBetweenMid) {
                points231.C[0] = courtWidth - distBetweenMid;
            }
        }

        function updateWR(paletX, paletY, paletLabel) {
            let rot = calcRot231(paletX);
            if (rot > 0.4) rot = 0.4;
            
            if (paletLabel === 'WR') {
                points231.WR = [paletX, paletY - 0.2];
            } else if (paletLabel === 'FL') {
                const [xC, yC] = points231.C;
                points231.WR = [xC + distBetweenMid, paletY - 0.2 - 1 - rot];
            } else if (paletLabel === 'FR') {
                points231.WR = [paletX + distBetweenMid/2, paletY - 1 - 0.2 - rot];
            } else if (paletLabel === 'WL') {
                const [xWL, yWL] = points231.WL;
                points231.WR = [paletX + 2*distBetweenMid, yWL - 2*rot];
            } else if (paletLabel === 'C') {
                const [xC, yC] = points231.C;
                points231.WR = [paletX + distBetweenMid, yC - rot];
            } else if (paletLabel === 'FB') {
                points231.WR = [paletX + distBetweenMid, paletY];
            } else {
                points231.WR = [paletX + distBetweenMid, paletY - distanceMilieuPuck - rot - 0.2];
            }
            
            if (points231.WR[0] < 2*distBetweenMid) {
                points231.WR[0] = 2*distBetweenMid;
            }
        }

        function updateFB(paletX, paletY, paletLabel) {
            if (paletLabel === 'FB') {
                points231.FB = [paletX, paletY - 0.2];
            } else if (paletLabel === 'FL') {
                points231.FB = [paletX + distBetweenForward/2, paletY - 0.2 - 2];
            } else if (paletLabel === 'FR') {
                points231.FB = [paletX - distBetweenForward/2, paletY - 0.2 - 2];
            } else if (paletLabel === 'WR') {
                points231.FB = [paletX, paletY - 1];
            } else if (paletLabel === 'WL') {
                points231.FB = [paletX, paletY - 1];
            } else if (paletLabel === 'C') {
                points231.FB = [paletX, paletY - 1];
            } else {
                points231.FB = [paletX, paletY - distFBPuck];
            }
        }

        // Update all positions for 231 formation
        function updatePositions231(paletX, paletY, paletLabel = null) {
            if (animationActive) {
                // Si on est encore dans la phase animée : ne rien faire ici
                return; 
            }
            updateFL(paletX, paletY, paletLabel);
            updateFR(paletX, paletY, paletLabel);
            updateWL(paletX, paletY, paletLabel);
            updateC(paletX, paletY, paletLabel);
            updateWR(paletX, paletY, paletLabel);
            updateFB(paletX, paletY, paletLabel);
            
            // Restrict positions to stay within the court
            for (const player in points231) {
                let x = points231[player][0];
                let y = points231[player][1];
                
                if (x < 0) x = 0;
                else if (x > courtWidth) x = courtWidth;
                
                if (y < 0) y = 0;
                else if (y > courtLength) y = courtLength;
                
                points231[player] = [x, y];
            }
        }

        // Position update functions for 33 formation
        function updateAG(paletX, paletY, paletLabel) {
            const rot = calcRot33(paletX);
            
            if (paletLabel === 'AG') {
                points33.AG = [paletX, paletY - 0.2];
            } else if (paletLabel === 'AD') {
                points33.AG = [paletX - 2*distBetweenForward, paletY - 0.2 + rot];
            } else if (paletLabel === 'AVC') {
                points33.AG = [paletX - distBetweenForward, paletY - 0.2 + rot/2];
            } else if (paletLabel === 'PD') {
                points33.AG = [paletX - 2*distBetweenForward, paletY + distEntreLigne + rot];
            } else if (paletLabel === 'PG') {
                points33.AG = [paletX, paletY + distEntreLigne];
            } else if (paletLabel === 'AR') {
                points33.AG = [paletX - distBetweenForward, paletY + distEntreLigne + rot/2];
            } else {
                points33.AG = [paletX - distBetweenForward, paletY - 1 + rot];
            }
            
            if (points33.AG[0] > courtWidth - 2*distBetweenForward) {
                points33.AG[0] = courtWidth - 2*distBetweenForward;
            }
        }

        function updateAVC(paletX, paletY, paletLabel) {
            const rot = calcRot33(paletX);
            
            if (paletLabel === 'AVC') {
                points33.AVC = [paletX, paletY - 0.2];
            } else if (paletLabel === 'AG') {
                points33.AVC = [paletX + distBetweenForward, paletY - 0.2 - rot/2];
            } else if (paletLabel === 'AD') {
                points33.AVC = [paletX - distBetweenForward, paletY - 0.2 + rot/2];
            } else if (paletLabel === 'PD') {
                points33.AVC = [paletX - distBetweenForward, paletY + distEntreLigne + rot/2];
            } else if (paletLabel === 'PG') {
                points33.AVC = [paletX + distBetweenForward, paletY + distEntreLigne - rot/2];
            } else if (paletLabel === 'AR') {
                points33.AVC = [paletX, paletY + distEntreLigne];
            } else {
                points33.AVC = [paletX, paletY - 1];
            }
        }

        function updateAD(paletX, paletY, paletLabel) {
            const rot = calcRot33(paletX);
            
            if (paletLabel === 'AD') {
                points33.AD = [paletX, paletY - 0.2];
            } else if (paletLabel === 'AG') {
                points33.AD = [paletX + 2*distBetweenForward, paletY - 0.2 - rot];
            } else if (paletLabel === 'AVC') {
                points33.AD = [paletX + distBetweenForward, paletY - 0.2 - rot/2];
            } else if (paletLabel === 'PD') {
                points33.AD = [paletX, paletY + 1];
            } else if (paletLabel === 'PG') {
                points33.AD = [paletX + 2*distBetweenForward, paletY + distEntreLigne - rot];
            } else if (paletLabel === 'AR') {
                points33.AD = [paletX + distBetweenForward, paletY + distEntreLigne - rot/2];
            } else {
                points33.AD = [paletX + distBetweenForward, paletY - 1 - rot];
            }
            
            if (points33.AD[0] < 2*distBetweenForward) {
                points33.AD[0] = 2*distBetweenForward;
            }
        }

        function updatePD(paletX, paletY, paletLabel) {
            const rot = calcRot33(paletX) * 1.4;
            
            if (paletLabel === 'PD') {
                points33.PD = [paletX, paletY - 0.2];
            } else if (paletLabel === 'AG') {
                points33.PD = [paletX + 2*distBetweenForward, paletY - distEntreLigne - rot];
            } else if (paletLabel === 'AD') {
                points33.PD = [paletX, paletY - distEntreLigne];
            } else if (paletLabel === 'AVC') {
                points33.PD = [paletX + distBetweenForward, paletY - distEntreLigne - rot/2];
            } else if (paletLabel === 'PG') {
                points33.PD = [paletX + 2*distBetweenForward, paletY - rot];
            } else if (paletLabel === 'AR') {
                points33.PD = [paletX + distBetweenForward, paletY - rot/2];
            } else {
                points33.PD = [paletX + distBetweenForward, paletY - 2 - rot];
            }
        }

        function updatePG(paletX, paletY, paletLabel) {
            const rot = calcRot33(paletX) * 1.4;
            
            if (paletLabel === 'PG') {
                points33.PG = [paletX, paletY - 0.2];
            } else if (paletLabel === 'AG') {
                points33.PG = [paletX, paletY - distEntreLigne];
            } else if (paletLabel === 'AD') {
                points33.PG = [paletX - 2*distBetweenForward, paletY - distEntreLigne + rot];
            } else if (paletLabel === 'AVC') {
                points33.PG = [paletX - distBetweenForward, paletY - distEntreLigne + rot/2];
            } else if (paletLabel === 'PD') {
                points33.PG = [paletX - 2*distBetweenForward, paletY + rot];
            } else if (paletLabel === 'AR') {
                points33.PG = [paletX - distBetweenForward, paletY + rot/2];
            } else {
                points33.PG = [paletX - distBetweenForward, paletY - 2 + rot];
            }
        }

        function updateAR(paletX, paletY, paletLabel) {
            const rot = calcRot33(paletX) * 1.2;
            
            if (paletLabel === 'AR') {
                points33.AR = [paletX, paletY - 0.2];
            } else if (paletLabel === 'AG') {
                points33.AR = [paletX + distBetweenForward, paletY - distEntreLigne - rot/2];
            } else if (paletLabel === 'AD') {
                points33.AR = [paletX - distBetweenForward, paletY - distEntreLigne + rot/2];
            } else if (paletLabel === 'AVC') {
                points33.AR = [paletX, paletY - distEntreLigne];
            } else if (paletLabel === 'PD') {
                points33.AR = [paletX - distBetweenForward, paletY + rot/2];
            } else if (paletLabel === 'PG') {
                points33.AR = [paletX + distBetweenForward, paletY - rot/2];
            } else {
                points33.AR = [paletX, paletY - 2];
            }
        }

        // Update all positions for 33 formation
        function updatePositions33(paletX, paletY, paletLabel = null) {
            updateAG(paletX, paletY, paletLabel);
            updateAVC(paletX, paletY, paletLabel);
            updateAD(paletX, paletY, paletLabel);
            updatePG(paletX, paletY, paletLabel);
            updateAR(paletX, paletY, paletLabel);
            updatePD(paletX, paletY, paletLabel);
            
            // Restrict positions to stay within the court
            for (const player in points33) {
                let x = points33[player][0];
                let y = points33[player][1];
                
                if (x < 0) x = 0;
                else if (x > courtWidth) x = courtWidth;
                
                if (y < 0) y = 0;
                else if (y > courtLength) y = courtLength;
                
                points33[player] = [x, y];
            }
        }

        // Draw the court
        function drawCourt() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw main rectangle (court)
            ctx.fillStyle = 'skyblue';
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.rect(
                courtToPixelX(0), 
                courtToPixelY(courtLength), 
                courtToPixelX(courtWidth) - courtToPixelX(0), 
                courtToPixelY(0) - courtToPixelY(courtLength)
            );
            ctx.fill();
            ctx.stroke();
            
            // Draw inner rectangle
            ctx.beginPath();
            ctx.rect(
                courtToPixelX(3), 
                courtToPixelY(courtLength-3), 
                courtToPixelX(courtWidth-3) - courtToPixelX(3), 
                courtToPixelY(3) - courtToPixelY(courtLength-3)
            );
            ctx.stroke();
            
            // Draw centerline
            ctx.beginPath();
            ctx.moveTo(courtToPixelX(0), courtToPixelY(courtLength / 2));
            ctx.lineTo(courtToPixelX(courtWidth), courtToPixelY(courtLength / 2));
            ctx.stroke();
            
            // Draw center circle
            const diametre = 3;
            ctx.beginPath();
            ctx.arc(
                courtToPixelX(courtWidth / 2), 
                courtToPixelY(courtLength / 2), 
                (diametre / 2) * scaleFactor, 
                0, 
                2 * Math.PI
            );
            ctx.stroke();
                // Draw bottom half-circles - fixed
            ctx.lineWidth = 2; // Make lines more visible
            drawArc(courtWidth / 2, 0, 3, 0, Math.PI); // Small half-circle (radius 1.5)
            drawArc(courtWidth / 2, 0, 6, 0, Math.PI); // Large half-circle (radius 3)
            
            // Draw top half-circles - fixed
            drawArc(courtWidth / 2, courtLength, 3, Math.PI, 2 * Math.PI); // Small half-circle (radius 1.5)
            drawArc(courtWidth / 2, courtLength, 6, Math.PI, 2 * Math.PI); // Large half-circle (radius 3)

            // --- AJOUTER WATERMARK ---
            ctx.save();
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Kaëlig', canvas.width - 10, canvas.height - 5);
            ctx.restore();
            // --- FIN WATERMARK ---
        }

        // Helper function to draw arcs
        function drawArc(x, y, diameter, startAngle, endAngle) {
            ctx.beginPath();
            ctx.arc(
                courtToPixelX(x), 
                courtToPixelY(y), 
                (diameter / 2) * scaleFactor, 
                startAngle, 
                endAngle
            );
            ctx.stroke();
        }

        // Draw the puck and players
        function drawPlayers() {
            // Draw puck
            ctx.beginPath();
            ctx.fillStyle = 'red';
            ctx.arc(courtToPixelX(puckX), courtToPixelY(puckY), 10, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw players based on current formation
            if (currentFormation === '231') {
                drawPlayer(points231.FL[0], points231.FL[1], 'blue', 'FL');
                drawPlayer(points231.FR[0], points231.FR[1], 'blue', 'FR');
                drawPlayer(points231.WL[0], points231.WL[1], 'green', 'WL');
                drawPlayer(points231.C[0], points231.C[1], 'green', 'C');
                drawPlayer(points231.WR[0], points231.WR[1], 'green', 'WR');
                drawPlayer(points231.FB[0], points231.FB[1], 'yellow', 'FB');
            } else {
                drawPlayer(points33.AG[0], points33.AG[1], 'blue', 'AG');
                drawPlayer(points33.AVC[0], points33.AVC[1], 'blue', 'AVC');
                drawPlayer(points33.AD[0], points33.AD[1], 'blue', 'AD');
                drawPlayer(points33.PG[0], points33.PG[1], 'green', 'PG');
                drawPlayer(points33.AR[0], points33.AR[1], 'green', 'AR');
                drawPlayer(points33.PD[0], points33.PD[1], 'green', 'PD');
            }
        }

        // Helper function to draw a player
        function drawPlayer(x, y, color, label) {
            // Décalage vertical si un joueur a le palet
            let yOffset = 0;
            if (selectedPlayer) {
                yOffset = 8 / scaleFactor; // 8 pixels convertis en unités terrain
            }
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(courtToPixelX(x), courtToPixelY(y - yOffset), 12, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add label
            ctx.fillStyle = 'white';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, courtToPixelX(x), courtToPixelY(y - yOffset) + 3);
        }

        // Helper function to handle start of interaction (mouse or touch)
        function handleStart(event) {
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            let pixelX, pixelY;
            
            // Handle both mouse and touch events
            if (event.type === 'mousedown') {
                pixelX = event.clientX - rect.left;
                pixelY = event.clientY - rect.top;
            } else if (event.type === 'touchstart') {
                pixelX = event.touches[0].clientX - rect.left;
                pixelY = event.touches[0].clientY - rect.top;
            }
            
            // Convert to court coordinates
            const courtX = pixelX / scaleFactor;
            const courtY = (canvas.height - pixelY) / scaleFactor;
            
            // Check if a player was clicked
            let playerClicked = checkPlayerClick(courtX, courtY);
            
            if (playerClicked) {
                // Select the player
                selectedPlayer = playerClicked;
                isDragging = false;
            } else {
                // Start dragging the puck
                startDragX = courtX;
                startDragY = courtY;
                startPuckX = puckX;
                startPuckY = puckY;
                isDragging = true;
                
                // Move the puck to the clicked position
                puckX = courtX;
                puckY = courtY;
                
                // Update positions based on the selected formation
                if (currentFormation === '231') {
                    updatePositions231(puckX, puckY, selectedPlayer);
                } else {
                    updatePositions33(puckX, puckY, selectedPlayer);
                }
            }
            
            // Redraw everything
            drawCourt();
            drawPlayers();
        }

        // Helper function to handle move during interaction (mouse or touch)
        function handleMove(event) {
            if (!isDragging) return;
            
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            let pixelX, pixelY;
            
            // Handle both mouse and touch events
            if (event.type === 'mousemove') {
                pixelX = event.clientX - rect.left;
                pixelY = event.clientY - rect.top;
            } else if (event.type === 'touchmove') {
                pixelX = event.touches[0].clientX - rect.left;
                pixelY = event.touches[0].clientY - rect.top;
            }
            
            // Convert to court coordinates
            const courtX = pixelX / scaleFactor;
            const courtY = (canvas.height - pixelY) / scaleFactor;
            
            // Calculate the translation from the start of the drag
            const deltaX = courtX - startDragX;
            const deltaY = courtY - startDragY;
            
            // Apply the translation to the puck (relative to its original position)
            puckX = Math.max(0, Math.min(courtWidth, startPuckX + deltaX));
            puckY = Math.max(0, Math.min(courtLength, startPuckY + deltaY));
            
            // Update positions based on the selected formation
            if (currentFormation === '231') {
                updatePositions231(puckX, puckY, selectedPlayer);
            } else {
                updatePositions33(puckX, puckY, selectedPlayer);
            }
            
            // Redraw everything
            drawCourt();
            drawPlayers();
        }

        // Helper function to handle end of interaction (mouse or touch)
        function handleEnd(event) {
            isDragging = false;
        }

        // Mouse events
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);

        // Touch events for mobile devices
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        // Check if a player was clicked
        function checkPlayerClick(x, y) {
            const clickRadius = 0.8; // Radius for click detection
            
            if (currentFormation === '231') {
                for (const player in points231) {
                    const [playerX, playerY] = points231[player];
                    const distance = Math.sqrt(Math.pow(x - playerX, 2) + Math.pow(y - playerY, 2));
                    if (distance < clickRadius) {
                        return player;
                    }
                }
            } else {
                for (const player in points33) {
                    const [playerX, playerY] = points33[player];
                    const distance = Math.sqrt(Math.pow(x - playerX, 2) + Math.pow(y - playerY, 2));
                    if (distance < clickRadius) {
                        return player;
                    }
                }
            }
            
            return null;
        }

        // Initialize event handlers for buttons
        function setupEventHandlers() {
            // Toggle formation button (switch between 2-3-1 and 3-3)
            const toggleFormationBtn = document.getElementById('toggle-formation');
            if (toggleFormationBtn) {
                // Make sure text reflects the current formation (default is 33)
                toggleFormationBtn.textContent = 'Switch to 2-3-1';
                document.getElementById('buttons-33').style.display = 'flex';
                document.getElementById('buttons-231').style.display = 'none';
                toggleFormationBtn.addEventListener('click', function() {
                    currentFormation = currentFormation === '231' ? '33' : '231';
                    selectedPlayer = null;
                    
                    // Update button text
                    this.textContent = currentFormation === '231' ? 'Switch to 3-3' : 'Switch to 2-3-1';
                    
                    // Show/hide appropriate player buttons
                    document.getElementById('buttons-33').style.display = currentFormation === '33' ? 'flex' : 'none';
                    document.getElementById('buttons-231').style.display = currentFormation === '231' ? 'flex' : 'none';
                    
                    // Update positions based on the selected formation
                    if (currentFormation === '231') {
                        updatePositions231(puckX, puckY);
                    } else {
                        updatePositions33(puckX, puckY);
                    }
                    
                    // Redraw everything
                    drawCourt();
                    drawPlayers();
                });
            }
                        
            // Player buttons for selecting a player
            const playerButtons = document.querySelectorAll('.player-btn');
            playerButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const playerLabel = this.getAttribute('data-player');
                    
                    // Toggle selection
                    if (selectedPlayer === playerLabel) {
                        selectedPlayer = null;
                        playerButtons.forEach(btn => btn.classList.remove('selected'));
                    } else {
                        selectedPlayer = playerLabel;
                        playerButtons.forEach(btn => btn.classList.remove('selected'));
                        this.classList.add('selected');
                    }
                    
                    // Mettre à jour la position des joueurs instantanément
                    if (currentFormation === '231') {
                        updatePositions231(puckX, puckY, selectedPlayer);
                    } else {
                        updatePositions33(puckX, puckY, selectedPlayer);
                    }
                    // Redraw with new selection
                    drawCourt();
                    drawPlayers();
                });
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                resizeCanvas();
            });
        }

        function animateInitialPositions(initialPositions, targetPositions) {
            let duration = 2000; // en ms
            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                let elapsed = timestamp - startTime;
                let progress = Math.min(elapsed / duration, 1);

                for (let key in points33) {
                    let [startX, startY] = initialPositions[key];
                    let [targetX, targetY] = targetPositions[key];

                    points33[key][0] = startX + (targetX - startX) * progress;
                    points33[key][1] = startY + (targetY - startY) * progress;
                }

                drawCourt();
                drawPlayers();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation is complete, set flag to false
                    animationActive = false;
                    
                    // Update positions properly when animation is done
                    updatePositions33(puckX, puckY);
                    updatePositions231(puckX, puckY);
                    
                    // Redraw everything with updated positions
                    drawCourt();
                    drawPlayers();
                }
            }

            requestAnimationFrame(animate);
        }

        // Initialize the visualization
        function init() {
            // Setup de base
            window.largeur = courtWidth;
            window.longueur = courtLength;
            
            // Ensure currentFormation is set to 33
            currentFormation = '33';
            
            // Set up event handlers
            setupEventHandlers();
            resizeCanvas();

            // 1. Initialize positions for animation
            let initialPositions = {
                'AG': [courtWidth/2-1, 0], 
                'AD': [courtWidth/2+1, 0],
                'AVC': [courtWidth/2, 0],
                'AR': [courtWidth/2+3, 0],
                'PD': [courtWidth/2+2, 0],
                'PG': [courtWidth/2-2, 0]
            };

            // 2. Set points33 to initial positions
            points33 = JSON.parse(JSON.stringify(initialPositions)); 

            // 3. Update points33 to get target positions
            updatePositions33(puckX, puckY);
            
            // Also update 231 formation to be ready
            updatePositions231(puckX, puckY);

            // Make a copy of the target positions
            let targetPositions = JSON.parse(JSON.stringify(points33));

            // 4. Reset points33 to starting positions
            points33 = JSON.parse(JSON.stringify(initialPositions));

            // 5. Start animation
            animateInitialPositions(initialPositions, targetPositions);
            
            // After animation is done, the animationActive flag will be set to false
            
            // Initial drawing
            drawCourt();
            drawPlayers();
        }

        // Start the visualization when the window loads
        window.onload = init;
    </script>
</body>
</html>
